---
sidebar_label: Conditions de course - Condition
sidebar_position: 6
description: Conditions de course et solution Condition
---

# Conditions de course et solution avec Condition

L'objet `Condition` est un m√©canisme de synchronisation avanc√© qui permet aux
threads d'attendre qu'une condition sp√©cifique soit remplie avant de continuer
leur ex√©cution. Il s'agit d'un concept fondamental dans la programmation
concurrente, particuli√®rement utile pour impl√©menter des patterns complexes
comme le producteur-consommateur.

### Qu'est-ce qu'une Condition ?

Une `Condition` est essentiellement un verrou (lock) associ√© √† une ou plusieurs
conditions logiques. Elle permet de :

- **Attendre** qu'une condition soit vraie avec `wait()`
- **Notifier** un ou plusieurs threads en attente avec `notify()` ou `notify_all()`
- **Prot√©ger** l'acc√®s aux ressources partag√©es comme un verrou classique

### Avantages par rapport aux verrous simples

1. **Attente intelligente** : Au lieu de faire du polling (v√©rification
   continue), les threads peuvent se mettre en attente passive
2. **√âconomie de ressources** : Pas de consommation CPU inutile pendant l'attente
3. **Synchronisation fine** : Permet de coordonner pr√©cis√©ment les actions entre threads
4. **√âvite les blocages** : R√©duit les risques de deadlock gr√¢ce √† la notification explicite

## Comprendre l'objet Condition en d√©tail

### Cr√©ation et utilisation de base

Un objet `Condition` s'utilise toujours avec le mot-cl√© `with` pour garantir une gestion correcte du verrou :

```python
import threading

# Cr√©ation d'un objet Condition
condition = threading.Condition()

# Utilisation correcte avec 'with'
with condition:
    # Zone critique prot√©g√©e par le verrou
    # Ici, on peut utiliser wait(), notify(), notify_all()
    pass
```

### Les trois op√©rations principales

-  `wait()` - Attendre passivement. La m√©thode `wait()` met le thread courant
   en attente jusqu'√† ce qu'un autre thread le r√©veille.
-  `notify()` - R√©veiller un thread. La m√©thode `notify()` r√©veille un seul
   thread en attente.
-  `notify_all()` - R√©veiller tous les threads. La m√©thode `notify_all()` r√©veille
   tous les threads en attente.

Voici un exemple simple avec deux threads qui attendent qu'un compteur atteigne
une certaine valeur :

```python
import threading
import time

compteur = 0
condition = threading.Condition()

def attendre_compteur_atteint(valeur_cible):
    """Thread qui attend que le compteur atteigne une valeur"""
    with condition:
        while compteur < valeur_cible:
            print(f"‚è≥ Attente... compteur={compteur}, cible={valeur_cible}")
            condition.wait()  # ‚Üê Le thread se met en PAUSE ici
        print(f"‚úÖ Objectif atteint ! compteur={compteur}")

def incrementer_compteur():
    """Thread qui incr√©mente le compteur"""
    global compteur
    for i in range(10):
        time.sleep(0.5)  # Simule du travail
        
        with condition:
            compteur += 1
            print(f"üìà Compteur incr√©ment√©: {compteur}")
            condition.notify_all()  # ‚Üê R√©veille tous les threads en attente

# Test
t1 = threading.Thread(target=attendre_compteur_atteint, args=(5,))
t2 = threading.Thread(target=attendre_compteur_atteint, args=(8,))
t3 = threading.Thread(target=incrementer_compteur)

t1.start()
t2.start()
t3.start()

t1.join()
t2.join()
t3.join()
```

### Diff√©rence crucial : `notify()` vs `notify_all()`

| M√©thode | Effet | Quand l'utiliser |
|---------|-------|------------------|
| `notify()` | R√©veille **1 seul** thread | Quand une seule ressource devient disponible |
| `notify_all()` | R√©veille **tous** les threads | Quand la condition peut concerner plusieurs threads |

### Le pattern `while` + `wait()` : Pourquoi c'est obligatoire

‚ùå **INCORRECT** - Ne jamais faire √ßa :
```python
with condition:
    if not condition_ok:
        condition.wait()  # Dangereux !
    # faire quelque chose
```

‚úÖ **CORRECT** - Toujours utiliser `while` :
```python
with condition:
    while not condition_ok:
        condition.wait()  # S√ªr !
    # faire quelque chose
```

**Pourquoi `while` ?** √Ä cause des "spurious wakeups" :
- Un thread peut se r√©veiller sans qu'aucun `notify()` n'ait √©t√© appel√©, car le
  syst√®me d'exploitation peut r√©veiller le thread pour d'autres raisons
- La boucle `while` v√©rifie √† nouveau la condition apr√®s le r√©veil

## Pattern Producteur-Consommateur

Le pattern producteur-consommateur est un des plus utilis√©s en programmation
concurrente. Il permet de d√©coupler la production et la consommation de donn√©es
gr√¢ce √† un buffer interm√©diaire.

```python
import threading
import time
import random
from collections import deque

class ProducteurConsommateur:
    """Pattern Producteur-Consommateur avec Condition"""
    
    def __init__(self, taille_max_buffer=5):
        self.buffer = deque()
        self.taille_max = taille_max_buffer
        self.condition = threading.Condition()
        self.production_terminee = False
    
    def produire(self, producteur_id, nb_items):
        """Produit des items"""
        for i in range(nb_items):
            item = f"Item-{producteur_id}-{i+1}"
            
            with self.condition:
                # Attendre que le buffer ne soit pas plein
                while len(self.buffer) >= self.taille_max:
                    print(f"üî¥ Producteur-{producteur_id}: Buffer plein, attente...")
                    self.condition.wait()
                
                # Ajouter l'item
                self.buffer.append(item)
                print(f"üì¶ Producteur-{producteur_id}: Produit {item} (buffer: {len(self.buffer)})")
                
                # Notifier les consommateurs
                self.condition.notify_all()
            
            # Simuler le temps de production
            time.sleep(random.uniform(0.1, 0.5))
        
        print(f"‚úÖ Producteur-{producteur_id}: Production termin√©e")
    
    def consommer(self, consommateur_id, nb_items):
        """Consomme des items"""
        items_consommes = 0
        
        while items_consommes < nb_items:
            with self.condition:
                # Attendre qu'il y ait des items ou que la production soit termin√©e
                while len(self.buffer) == 0 and not self.production_terminee:
                    print(f"üîµ Consommateur-{consommateur_id}: Buffer vide, attente...")
                    self.condition.wait()
                
                # Si le buffer est vide et la production termin√©e, arr√™ter
                if len(self.buffer) == 0 and self.production_terminee:
                    break
                
                # Consommer un item
                if self.buffer:
                    item = self.buffer.popleft()
                    items_consommes += 1
                    print(f"üçΩÔ∏è  Consommateur-{consommateur_id}: Consomme {item} (buffer: {len(self.buffer)})")
                    
                    # Notifier les producteurs
                    self.condition.notify_all()
            
            # Simuler le temps de consommation
            time.sleep(random.uniform(0.2, 0.8))
        
        print(f"‚úÖ Consommateur-{consommateur_id}: Consommation termin√©e ({items_consommes} items)")
    
    def terminer_production(self):
        """Indique que la production est termin√©e"""
        with self.condition:
            self.production_terminee = True
            self.condition.notify_all()

def test_producteur_consommateur():
    """Test du pattern producteur-consommateur"""
    print("=== Test Producteur-Consommateur ===")
    
    pc = ProducteurConsommateur(taille_max_buffer=3)
    threads = []
    
    # Cr√©er les producteurs
    for i in range(2):
        t = threading.Thread(
            target=pc.produire,
            args=(i+1, 5),
            name=f"Producteur-{i+1}"
        )
        threads.append(t)
        t.start()
    
    # Cr√©er les consommateurs
    for i in range(2):
        t = threading.Thread(
            target=pc.consommer,
            args=(i+1, 6),
            name=f"Consommateur-{i+1}"
        )
        threads.append(t)
        t.start()
    
    # Attendre que tous les producteurs terminent
    for t in threads[:2]:  # Les 2 premiers threads sont les producteurs
        t.join()
    
    # Signaler la fin de production
    pc.terminer_production()
    
    # Attendre les consommateurs
    for t in threads[2:]:
        t.join()
    
    print("Test termin√©")

test_producteur_consommateur()
```

## Analyse d√©taill√©e du code

### Structure de la classe ProducteurConsommateur

La classe encapsule tous les √©l√©ments n√©cessaires pour une synchronisation s√ªre :

```python
def __init__(self, taille_max_buffer=5):
    self.buffer = deque()              # Buffer thread-safe
    self.taille_max = taille_max_buffer
    self.condition = threading.Condition()  # Objet de synchronisation
    self.production_terminee = False    # Flag d'arr√™t
```

- **`deque`** : Structure de donn√©es thread-safe pour le buffer
- **`Condition`** : Objet central pour la synchronisation
- **`production_terminee`** : Flag bool√©en pour signaler l'arr√™t

### M√©canisme d'attente et de notification

#### Dans le producteur :
```python
with self.condition:
    while len(self.buffer) >= self.taille_max:
        self.condition.wait()  # Attente passive
    
    # Production
    self.buffer.append(item)
    self.condition.notify_all()  # R√©veil des consommateurs
```

#### Dans le consommateur :
```python
with self.condition:
    while len(self.buffer) == 0 and not self.production_terminee:
        self.condition.wait()  # Attente passive
    
    # Consommation
    item = self.buffer.popleft()
    self.condition.notify_all()  # R√©veil des producteurs
```

### Bonnes pratiques observ√©es

1. **Utilisation de `with`** : Garantit l'acquisition et la lib√©ration du verrou
2. **Boucle `while` avec `wait()`** : √âvite les r√©veils intempestifs (spurious wakeups)
3. **`notify_all()`** : Assure que tous les threads concern√©s sont notifi√©s
4. **Condition d'arr√™t claire** : Le flag `production_terminee` permet un arr√™t propre


## Comparaison avec d'autres m√©canismes

| M√©canisme | Avantages | Inconv√©nients | Cas d'usage |
|-----------|-----------|---------------|-------------|
| **Lock** | Simple, rapide | Pas d'attente intelligente | Protection basique |
| **Semaphore** | Compteur de ressources | Pas de condition complexe | Limitation de ressources |
| **Condition** | Attente intelligente, notifications | Plus complexe | Synchronisation avanc√©e |

## Conclusion

L'objet `Condition` est un outil puissant pour la synchronisation avanc√©e entre
threads. Il permet d'impl√©menter des patterns complexes tout en √©vitant les
probl√®mes de performance li√©s au polling actif. Bien que plus complexe qu'un
simple verrou, il offre une flexibilit√© incomparable pour coordonner
l'ex√©cution de threads selon des conditions m√©tier sp√©cifiques.
