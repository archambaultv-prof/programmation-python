---
sidebar_label: Conditions de course - Semaphore
sidebar_position: 5
description: Conditions de course et solution Semaphore
---

# Semaphore

## Introduction

Le `Semaphore` est un m√©canisme de synchronisation qui limite le nombre de
threads qui peuvent acc√©der simultan√©ment √† une ressource partag√©e.
Contrairement au `Lock` qui n'autorise qu'un seul thread √† la fois, le
semaphore permet √† un nombre d√©fini de threads d'acc√©der √† la ressource.

## Concept

Un semaphore maintient un compteur interne qui repr√©sente le nombre de "permissions" disponibles :
- Lorsqu'un thread appelle `acquire()`, le compteur diminue
- Lorsqu'un thread appelle `release()`, le compteur augmente
- Si le compteur atteint z√©ro, les threads suivants sont bloqu√©s jusqu'√† ce qu'une permission soit lib√©r√©e

## Cas d'usage typiques

- **Pool de connexions** : Limiter le nombre de connexions simultan√©es √† une base de donn√©es
- **Limitation de bande passante** : Contr√¥ler le nombre de t√©l√©chargements simultan√©s
- **Gestion de ressources** : Limiter l'acc√®s √† des imprimantes, fichiers, ou autres ressources physiques

## Exemple pratique : Pool de connexions

Voici un exemple simple d'utilisation d'un `Semaphore` pour g√©rer un pool de
connexions limit√©es.

```python
import threading
import time
import random

class PoolConnexions:
    """Simule un pool de connexions limit√©es"""
    
    def __init__(self, max_connexions=3):
        self.max_connexions = max_connexions
        self.semaphore = threading.Semaphore(max_connexions)
        self.connexions_actives = 0
        self.lock_stats = threading.Lock()
    
    def utiliser_connexion(self, duree_utilisation):
        """Utilise une connexion du pool"""
        nom_thread = threading.current_thread().name
        
        print(f"{nom_thread}: Demande de connexion...")
        
        # Acqu√©rir une "connexion" (semaphore) avec context manager
        with self.semaphore:
            # Incr√©menter le compteur de fa√ßon thread-safe
            with self.lock_stats:
                self.connexions_actives += 1
                print(f"‚úÖ {nom_thread}: Connexion obtenue ({self.connexions_actives}/{self.max_connexions} utilis√©es)")
            
            # Simuler l'utilisation de la connexion
            time.sleep(duree_utilisation)
            
            print(f"üîÑ {nom_thread}: Utilisation termin√©e")
            
            # D√©cr√©menter le compteur de fa√ßon thread-safe
            with self.lock_stats:
                self.connexions_actives -= 1
            print(f"üîì {nom_thread}: Connexion lib√©r√©e")

def client_database(pool, client_id):
    """Simule un client qui utilise la base de donn√©es"""
    for i in range(2):
        duree = random.uniform(1, 3)
        pool.utiliser_connexion(duree)
        
        # Pause entre les utilisations
        time.sleep(random.uniform(0.5, 1))

# Test du pool de connexions
print("=== Test Pool de Connexions avec Semaphore ===")
pool = PoolConnexions(max_connexions=2)

threads = []
for i in range(4):  # Plus de clients que de connexions disponibles
    thread = threading.Thread(
        target=client_database,
        args=(pool, i+1),
        name=f"Client-{i+1}"
    )
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("Tous les clients ont termin√©")
```

## Analyse du comportement

Dans cet exemple :

1. **Semaphore(2)** : Seules 2 connexions simultan√©es sont autoris√©es
2. **4 clients** : Plus de demandes que de ressources disponibles
3. **Gestion automatique** : Les threads en exc√®s attendent automatiquement

### Sortie attendue

```
=== Test Pool de Connexions avec Semaphore ===
Client-1: Demande de connexion...
‚úÖ Client-1: Connexion obtenue (1/2 utilis√©es)
Client-2: Demande de connexion...
‚úÖ Client-2: Connexion obtenue (2/2 utilis√©es)
Client-3: Demande de connexion...
Client-4: Demande de connexion...
üîÑ Client-1: Utilisation termin√©e
üîì Client-1: Connexion lib√©r√©e
‚úÖ Client-3: Connexion obtenue (2/2 utilis√©es)
...
```

## Semaphore vs Lock

| Caract√©ristique | Lock | Semaphore |
|------------------|------|-----------|
| **Acc√®s simultan√©** | 1 thread | N threads configurables |
| **Usage typique** | Protection donn√©es critiques | Limitation de ressources |
| **Blocage** | Exclusion mutuelle totale | Limitation contr√¥l√©e |

