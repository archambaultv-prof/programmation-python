---
sidebar_label: Conditions de course - Intro
sidebar_position: 2
description: Conditions de course
---

# Conditions de course

## Introduction

Les **conditions de course** (race conditions) repr√©sentent l'un des d√©fis les
plus subtils et dangereux de la programmation concurrente. Elles surviennent
quand plusieurs threads acc√®dent simultan√©ment √† des ressources partag√©es
(variables, fichiers, connexions r√©seau) sans coordination appropri√©e, causant
des comportements impr√©visibles et des bugs difficiles √† reproduire.

### Pourquoi les conditions de course sont-elles probl√©matiques ?

1. **Impr√©visibilit√©** : Le r√©sultat d√©pend de l'ordre d'ex√©cution des threads, qui varie √† chaque ex√©cution
2. **Difficult√© de debugging** : Les bugs peuvent ne pas appara√Ætre en d√©veloppement mais survenir en production
3. **Corruption de donn√©es** : Les donn√©es partag√©es peuvent finir dans un √©tat incoh√©rent
4. **Comportement non d√©terministe** : Le m√™me code peut produire des r√©sultats diff√©rents

### Contexte et enjeux

Dans un environnement multi-thread√©, les threads partagent le m√™me espace
m√©moire. Cela signifie qu'ils peuvent tous acc√©der aux m√™mes variables
globales, objets partag√©s, et autres ressources. Sans m√©canismes de
synchronisation, plusieurs probl√®mes peuvent survenir :

- **Lecture/√©criture simultan√©es** : Un thread lit une valeur pendant qu'un autre la modifie
- **√âtats interm√©diaires** : Un thread voit des donn√©es dans un √©tat incoh√©rent temporaire
- **Pertes de donn√©es** : Des modifications sont √©cras√©es par d'autres threads
- **Violations d'invariants** : Les r√®gles m√©tier ne sont plus respect√©es

Ce chapitre explore ces probl√®mes en d√©tail et pr√©sente les solutions robustes
pour les r√©soudre.

## Qu'est-ce qu'une condition de course ?

Une condition de course se produit quand le r√©sultat d'un programme d√©pend de
l'ordre d'ex√©cution des threads, qui est impr√©visible et contr√¥l√© par le
planificateur du syst√®me d'exploitation. Le nom "course" vient du fait que les
threads sont en "course" pour acc√©der √† la ressource partag√©e.

### Anatomie d'une condition de course

Pour qu'une condition de course se produise, trois conditions doivent √™tre r√©unies :

1. **Ressource partag√©e** : Plusieurs threads acc√®dent √† la m√™me donn√©e
2. **Modification de donn√©es** : Au moins un thread modifie la ressource
3. **Absence de synchronisation** : Aucun m√©canisme ne coordonne les acc√®s

### Pourquoi cela pose-t-il probl√®me ?

Les op√©rations qui nous semblent "atomiques" en Python ne le sont souvent pas
au niveau du processeur. Par exemple, l'instruction `compteur += 1` se
d√©compose en r√©alit√© en plusieurs √©tapes :

1. **LOAD** : Charger la valeur de `compteur` dans un registre
2. **ADD** : Ajouter 1 √† cette valeur
3. **STORE** : Sauvegarder le r√©sultat dans `compteur`

Si deux threads ex√©cutent ces √©tapes en m√™me temps, ils peuvent lire la m√™me
valeur initiale et produire un r√©sultat incorrect.

### Exemple simple de condition de course

Cet exemple d√©montre concr√®tement comment une condition de course peut se produire
avec un cas simple mais r√©v√©lateur : l'incr√©mentation d'un compteur par
plusieurs threads.

```python
import threading
import time

# Variable globale partag√©e - source potentielle de race condition
compteur = 0

def incrementer_compteur(nb_iterations):
    """Fonction qui incr√©mente le compteur - CONTIENT UNE CONDITION DE COURSE

    Cette fonction illustre parfaitement le probl√®me des conditions de course.
    Chaque thread tente d'incr√©menter le compteur global, mais sans
    synchronisation, les r√©sultats sont impr√©visibles.
    
    Args:
        nb_iterations (int): Nombre d'incr√©mentations √† effectuer
    """
    global compteur
    nom_thread = threading.current_thread().name
    
    for i in range(nb_iterations):
        # ‚ùå RACE CONDITION ICI - SECTION CRITIQUE NON PROT√âG√âE
        # Cette op√©ration simple se d√©compose en r√©alit√© en 3 √©tapes :
        # 1. Lire la valeur actuelle de 'compteur'
        # 2. Calculer la nouvelle valeur (valeur_actuelle + 1)  
        # 3. √âcrire la nouvelle valeur dans 'compteur'
        
        valeur_actuelle = compteur                    # √âtape 1: LECTURE
        time.sleep(0.000001)                         # Simule une op√©ration qui prend du temps
        compteur = valeur_actuelle + 1               # √âtapes 2 & 3: CALCUL et √âCRITURE
        
        # Affichage p√©riodique pour suivre le progr√®s
        if i % 1000 == 0:
            print(f"{nom_thread}: {i}/{nb_iterations} (compteur = {compteur})")

def demonstration_condition_de_course():
    """D√©montre de mani√®re reproductible une condition de course
    
    Cette fonction orchestre plusieurs threads pour cr√©er les conditions
    n√©cessaires √† l'apparition d'une condition de course et mesure l'impact
    sur le r√©sultat final.
    """
    global compteur

    print("=== D√©monstration Condition de Course ===")
    print("Chaque thread va incr√©menter le compteur plusieurs fois...")
    print("Sans synchronisation, le r√©sultat final sera incorrect.\n")
    
    # R√©initialiser le compteur
    compteur = 0
    
    # Param√®tres de test
    nb_iterations = 5000     # Assez grand pour voir l'effet
    nb_threads = 3           # Plusieurs threads en comp√©tition
    
    threads = []
    start_time = time.time()
    
    print(f"Configuration: {nb_threads} threads, {nb_iterations} incr√©ments chacun")
    print(f"R√©sultat attendu: {nb_threads * nb_iterations}\n")
    
    # Cr√©er et lancer tous les threads simultan√©ment
    for i in range(nb_threads):
        thread = threading.Thread(
            target=incrementer_compteur,
            args=(nb_iterations,),
            name=f"Thread-{i+1}"
        )
        threads.append(thread)
        thread.start()
        print(f"D√©marrage de {thread.name}")
    
    # Attendre que tous les threads se terminent
    for thread in threads:
        thread.join()
        print(f"{thread.name} termin√©")
    
    duree = time.time() - start_time
    resultat_attendu = nb_threads * nb_iterations
    
    # Analyser les r√©sultats
    print(f"\n=== R√©sultats ===")
    print(f"R√©sultat attendu: {resultat_attendu:,}")
    print(f"R√©sultat obtenu:  {compteur:,}")
    print(f"Diff√©rence:       {resultat_attendu - compteur:,}")
    print(f"Pourcentage d'erreur: {((resultat_attendu - compteur) / resultat_attendu * 100):.1f}%")
    print(f"Temps d'ex√©cution: {duree:.2f}s")
    
    if compteur != resultat_attendu:
        print("\n‚ùå RACE CONDITION D√âTECT√âE!")
        print("Les threads ont interf√©r√© les uns avec les autres.")
        print("Certaines incr√©mentations ont √©t√© perdues.")
    else:
        print("\n‚úÖ Pas de race condition d√©tect√©e (par chance rare)")
        print("Relancez le programme plusieurs fois pour voir l'effet.")

# Ex√©cuter la d√©monstration
if __name__ == "__main__":
    print("Ce programme d√©montre une race condition classique.")
    print("Ex√©cutez-le plusieurs fois pour voir des r√©sultats diff√©rents.\n")
    
    demonstration_condition_de_course()
    
    print("\nüí° Observation:")
    print("√Ä chaque ex√©cution, vous devriez obtenir un r√©sultat diff√©rent.")
    print("C'est le signe caract√©ristique d'une condition de course.")
```

**Que se passe-t-il exactement ?**

Imaginons deux threads (A et B) qui ex√©cutent `compteur += 1` en m√™me temps quand `compteur = 5` :

```
Temps | Thread A          | Thread B          | Valeur compteur
------|-------------------|-------------------|----------------
1     | Lit compteur (5)  |                   | 5
2     |                   | Lit compteur (5)  | 5  
3     | Calcule 5 + 1 = 6 |                   | 5
4     |                   | Calcule 5 + 1 = 6 | 5
5     | √âcrit 6           |                   | 6
6     |                   | √âcrit 6           | 6
```

**R√©sultat :** Au lieu d'avoir `compteur = 7` (deux incr√©ments), nous avons `compteur = 6`. Un incr√©ment a √©t√© "perdu" !

**Facteurs qui aggravent le probl√®me :**
- Plus de threads = plus de conflits
- Plus d'op√©rations = plus d'opportunit√©s de conflit
- Op√©rations plus lentes = plus de chances d'entrelacement
