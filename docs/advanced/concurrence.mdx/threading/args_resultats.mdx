---
sidebar_label: Arguments et résultats
sidebar_position: 2
description: Gestion des arguments et des résultats dans les threads
---


## Passage d'arguments et récupération de résultats

Un défi courant avec les threads est la communication : comment passer des
données aux threads et comment récupérer leurs résultats ? Contrairement aux
fonctions normales qui retournent directement des valeurs, les threads
nécessitent des mécanismes spéciaux pour le partage de données.

### Le problème des valeurs de retour

Les threads ne peuvent pas retourner de valeurs comme les fonctions normales
parce que `thread.start()` ne retourne rien et `thread.join()` ne retourne que
`None`. Nous devons donc utiliser des structures de données partagées.

### Solution avec Queue (recommandée)

La classe `queue.Queue` fournit un moyen thread-safe de passer des données
entre threads. C'est la solution la plus robuste et la plus sûre.

```python
import threading
import time
import queue

def calculer_carre(nombre, resultat_queue):
    """Calcule le carré d'un nombre et stocke le résultat dans une queue
    
    Cette fonction montre comment un thread peut "retourner" un résultat
    en utilisant une queue thread-safe.
    
    Args:
        nombre (int): Le nombre à mettre au carré
        resultat_queue (queue.Queue): Queue pour stocker le résultat
    """
    print(f"Thread {threading.current_thread().name}: Calcul de {nombre}²")
    
    # Simuler un calcul qui prend du temps (ex: requête base de données)
    time.sleep(1)
    
    resultat = nombre ** 2
    
    # Stocker le résultat avec l'input original pour pouvoir les associer
    resultat_queue.put((nombre, resultat))
    
    print(f"Thread {threading.current_thread().name}: {nombre}² = {resultat}")

# Exemple d'utilisation pratique
print("=== Calcul parallèle de carrés ===")

# Créer une queue thread-safe pour collecter les résultats
resultats = queue.Queue()
threads = []

# Liste des nombres à traiter
nombres = [1, 2, 3, 4, 5]
print(f"Calcul de carrés pour: {nombres}")

# Créer un thread pour chaque nombre
for nombre in nombres:
    t = threading.Thread(
        target=calculer_carre, 
        args=(nombre, resultats),
        name=f"Calculator-{nombre}"
    )
    threads.append(t)
    t.start()

# Attendre que tous les calculs se terminent
for t in threads:
    t.join()

# Récupérer et afficher tous les résultats
print("\n=== Résultats ===")
tous_les_resultats = []

while not resultats.empty():
    nombre, carre = resultats.get()
    tous_les_resultats.append((nombre, carre))

# Trier les résultats par nombre original pour un affichage ordonné
tous_les_resultats.sort(key=lambda x: x[0])

for nombre, carre in tous_les_resultats:
    print(f"{nombre}² = {carre}")
```

### Autres méthodes de partage de données

```python
import threading
import time

# Méthode 1: Liste partagée avec verrou (pour plus tard)
resultats_partages = []
verrou = threading.Lock()

def calculer_avec_liste(nombre, index):
    """Exemple avec liste partagée (nécessite synchronisation)"""
    resultat = nombre ** 2
    time.sleep(0.5)
    
    # Cette approche nécessitera des verrous (voir chapitre race conditions)
    with verrou:
        resultats_partages.append((index, nombre, resultat))

# Méthode 2: Attributs d'instance (avec classe Thread personnalisée)
class CalculateurThread(threading.Thread):
    """Thread qui stocke son résultat comme attribut d'instance"""
    
    def __init__(self, nombre):
        super().__init__()
        self.nombre = nombre
        self.resultat = None  # Sera défini après calcul
        
    def run(self):
        """Calcule et stocke le résultat dans l'instance"""
        time.sleep(0.5)
        self.resultat = self.nombre ** 2
        print(f"Calculé: {self.nombre}² = {self.resultat}")

# Utilisation de la classe personnalisée
print("\n=== Avec classe personnalisée ===")
threads_calc = []

for nombre in [6, 7, 8]:
    t = CalculateurThread(nombre)
    threads_calc.append(t)
    t.start()

# Attendre et récupérer les résultats
for t in threads_calc:
    t.join()
    print(f"Résultat de {t.nombre}: {t.resultat}")
```

**Avantages de chaque méthode :**

1. **Queue** (recommandée) :
   - Thread-safe par défaut
   - Peut gérer des résultats complexes
   - Permet la communication bidirectionnelle
   - Gère automatiquement la synchronisation

2. **Attributs d'instance** :
   - Simple pour des résultats uniques
   - Encapsulation naturelle
   - Facile à débugger

3. **Variables partagées** :
   - Plus de contrôle
   - Nécessite une synchronisation manuelle
   - Plus risqué (race conditions)

## Gestion des exceptions dans les threads

```python
import threading
import time
import sys

def tache_avec_exception(nom, doit_echouer=False):
    """Tâche qui peut lever une exception"""
    try:
        print(f"{nom}: Démarrage")
        time.sleep(1)
        
        if doit_echouer:
            raise ValueError(f"Erreur simulée dans {nom}")
        
        print(f"{nom}: Succès")
    except Exception as e:
        print(f"{nom}: Erreur - {e}")
        # L'exception est gérée ici, elle ne remonte pas au thread principal

def tache_non_geree(nom):
    """Tâche avec exception non gérée"""
    print(f"{nom}: Démarrage")
    time.sleep(1)
    raise RuntimeError(f"Erreur non gérée dans {nom}")

# Gestionnaire d'exception global pour les threads
def gestionnaire_exception(args):
    print(f"Exception non gérée dans thread {args.thread.name}: {args.exc_value}")

# Installer le gestionnaire
threading.excepthook = gestionnaire_exception

# Test avec exception gérée
print("=== Exception gérée ===")
t1 = threading.Thread(target=tache_avec_exception, args=("Thread-1", True))
t1.start()
t1.join()

# Test avec exception non gérée
print("\n=== Exception non gérée ===")
t2 = threading.Thread(target=tache_non_geree, args=("Thread-2",))
t2.start()
t2.join()

print("Programme continué malgré les exceptions")
```

## Bonnes pratiques

### 1. Toujours utiliser join()

```python
import threading
import time

def tache_importante():
    """Tâche critique qui doit finir"""
    print("Début tâche importante")
    time.sleep(2)
    print("Tâche importante terminée")

# ❌ Mauvais: sans join()
print("=== Sans join() ===")
thread = threading.Thread(target=tache_importante)
thread.start()
print("Programme principal terminé (la tâche peut ne pas finir)")
time.sleep(0.1)  # Petit délai pour voir le problème

# ✅ Bon: avec join()
print("\n=== Avec join() ===")
thread = threading.Thread(target=tache_importante)
thread.start()
thread.join()  # Attend la fin du thread
print("Programme principal terminé (tâche garantie finie)")
```

### 2. Gestion propre des ressources

```python
import threading
import time

class GestionnaireRessource:
    def __init__(self):
        self.ressource_ouverte = False
    
    def ouvrir(self):
        print("Ouverture de la ressource")
        self.ressource_ouverte = True
    
    def fermer(self):
        if self.ressource_ouverte:
            print("Fermeture de la ressource")
            self.ressource_ouverte = False
    
    def utiliser(self, nom):
        if self.ressource_ouverte:
            print(f"{nom}: Utilisation de la ressource")
            time.sleep(1)

def worker_avec_ressource(nom, gestionnaire):
    """Worker qui utilise une ressource partagée"""
    try:
        gestionnaire.utiliser(nom)
    finally:
        # Nettoyage si nécessaire
        pass

# Utilisation
gestionnaire = GestionnaireRessource()
gestionnaire.ouvrir()

try:
    threads = []
    for i in range(3):
        t = threading.Thread(
            target=worker_avec_ressource, 
            args=(f"Worker-{i+1}", gestionnaire)
        )
        threads.append(t)
        t.start()
    
    # Attendre tous les threads
    for t in threads:
        t.join()
        
finally:
    gestionnaire.fermer()
```
