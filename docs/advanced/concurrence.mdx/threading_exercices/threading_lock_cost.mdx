---
sidebar_label: CoÃ»t d'un Lock
sidebar_position: 3
description: CoÃ»t d'un Lock
---

# ğŸ”’ğŸ’¸ CoÃ»t d'un Lock

## ğŸ¯ Objectif pÃ©dagogique

- Comprendre le coÃ»t de la synchronisation avec des verrous (Locks).
- Analyser l'impact des Locks sur les performances dans un contexte de
  concurrence.

## ğŸ“œ Ã‰noncÃ©

Lisez le code ci-dessous qui compare le temps d'exÃ©cution d'une fonction
effectuant un grand nombre d'incrÃ©mentations sur une variable partagÃ©e, avec et
sans verrouillage. Selon vous, quel est le ratio de temps entre les deux
approches ? ExÃ©cutez le code pour vÃ©rifier votre hypothÃ¨se. Pourquoi y a-t-il une
diffÃ©rence de performance ?

```python
import threading
import time

n = 0
lock = threading.Lock()

def with_lock():
    global n
    with lock:
        n += 1

def without_lock():
    global n
    n += 1

def many_iterations(func, iterations=1_000_000):
    for _ in range(iterations):
        func()

start = time.perf_counter()
thread = threading.Thread(target=lambda: many_iterations(with_lock))
thread.start()
thread.join()
end = time.perf_counter()
duration_with_lock = end - start
print(f"With lock: n={n}, time={end - start:.6f}s")

n = 0  # Reset n
start = time.perf_counter()
thread = threading.Thread(target=lambda: many_iterations(without_lock))
thread.start()
thread.join()
end = time.perf_counter()
duration_without_lock = end - start
print(f"Without lock: n={n}, time={end - start:.6f}s")

print(f"Lock duration: {duration_with_lock:.6f}s, Without lock duration: {duration_without_lock:.6f}s")
print(f"Ratio (with_lock / without_lock): {duration_with_lock / duration_without_lock:.2f}")
```
