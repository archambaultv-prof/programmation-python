---
sidebar_label: Threading 2
sidebar_position: 2
description: Threading 2
---

# üß∂ Threading 2

## üéØ Objectif p√©dagogique

- Identifier et reproduire diff√©rents types de conditions de course.
- Comprendre l'impact des conditions de course sur l'int√©grit√© des donn√©es.
- Analyser les r√©sultats impr√©visibles caus√©s par la concurrence.

## üìú √ânonc√©

### Partie 1 : Compte bancaire d√©faillant

Cr√©ez une classe `CompteBancaire` avec les m√©thodes suivantes en ajoutant des
`time.sleep()` pour simuler des op√©rations lentes. **N'utilisez pas encore de
synchronisation.**

```python
class CompteBancaire:
    def __init__(self, solde_initial=1000):
        self.solde = solde_initial
    
    def deposer(self, montant):
        # Simulation d'une op√©ration qui prend du temps
        # (v√©rifications, communications avec la banque, etc.)
        pass
    
    def retirer(self, montant):
        # V√©rifier si le solde est suffisant
        # Effectuer le retrait si possible
        pass
    
    def get_solde(self):
        return self.solde
```

### Partie 2 : Simulation de transactions concurrentes

Cr√©ez une fonction de test qui :
   - Cr√©e un compte avec 1000$
   - Lance 5 threads qui font chacun 10 d√©p√¥ts de 50$
   - Lance 3 threads qui font chacun 5 retraits de 100$
   - Affiche le solde final et l'historique


### Partie 3 : Analyse des probl√®mes

Ex√©cutez vos tests plusieurs fois et documentez :

1. **Probl√®mes observ√©s** :
   - Le solde final correspond-il au calcul attendu ?
   - Que se passe-t-il si on autorise les soldes n√©gatifs ?
   - Peut-on retirer plus d'argent que disponible ?

### Partie 4 : Synchronisation

Ajoutez des m√©canismes de synchronisation (comme des `Lock`) pour prot√©ger les
op√©rations critiques dans la classe `CompteBancaire`. R√©ex√©cutez les tests et
comparez les r√©sultats.
